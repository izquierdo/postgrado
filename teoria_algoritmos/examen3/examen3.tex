\documentclass{article}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[spanish]{babel}
\usepackage{qtree}

% Para codigo bonito
\newcommand{\singlespace}{\renewcommand{\baselinestretch}{1.0}}

\newcommand{\algoritmo}[2]
{
{
  \singlespace
  \begin{algorithm}[h]
    \caption{#1}
    \begin{algorithmic}[1]
      #2
    \end{algorithmic}
  \end{algorithm}
}
}

\newcommand{\theHalgorithm}{\arabic{algorithm}}

\lstset{mathescape=true,frame=single}

\newcommand{\asig}{\ensuremath{\leftarrow}}
\renewcommand{\lstlistingname}{Listado} %listings en español

\begin{document}

% Título

\title{Tarea 3 de Teoría de Algoritmos}
\author{Daniel Izquierdo \\ \#08-86809}
\date{2 de diciembre de 2008}

\maketitle

\renewcommand{\labelenumi}{\alph{enumi})}

% Pregunta 1
\section{}

\begin{enumerate}

 \item

Los vértices del grafo son subconjuntos de $A$, representados por una fila
de unos y ceros. El vértice objetivo es $A$. La búsqueda comienza a partir del vértice
que representa el conjunto vacío. Los sucesores de un vértice que representa el conjunto
$V$ son todos los $V \bigcup U$ tales que

$$
U \neq \emptyset \wedge U \in F \wedge V \bigcap U = \emptyset \text{ }(*)
$$

Este grafo no tiene ciclos. La explicación informal del por qué es que un nodo sólo tiene
como sucesores conjuntos con cardinalidad estrictamente mayor a la suya.

Si en un momento del backtracking consigo un nodo que ya visité anteriormente, entonces no hay solución
por ese camino. Esto se debe al hecho de que seguí buscando luego de visitarlo, lo que implica que ni él ni
ninguno de sus sucesores es el nodo final. Por lo tanto, al llegar a un nodo visitado previamente podemos
ignorar su rama del árbol. Un criterio de poda puede ser, entonces, eliminar ramas previamente visitadas.
Este criterio sólo es razonable para instancias pequeñas, ya que necesitamos espacio exponencial para marcar
los nodos como visitados (puede haber hasta $2^n$ nodos distintos para un $A$ de cardinalidad $n$).

 \item

\renewcommand{\labelenumii}{\arabic{enumii}.}

% F={{c,e,f}, {a,d,g}, {b,c,f}, {a,d}, {b,a,g}, {b,g}}
\begin{enumerate}
\item Comienzo la búsqueda en el conjunto vacío $\emptyset$. \\
      Nodo actual: $\emptyset$

\item Elijo para añadir el primer elemento de $F$ elegible según $(*)$: \{c,e,f\}
      Nodo actual: $\{c, e, f\}$

\item Elijo para añadir el primer elemento de $F$ elegible según $(*)$: \{a,d,g\}
      Nodo actual: $\{c,e,f,a,d,g\}$

\item No quedan sucesores del nodo actual; me retracto de mi última decisión.
      Nodo actual: $\{c, e, f\}$

\item Elijo para añadir el segundo elemento de $F$ elegible según $(*)$: \{a,d\}
      Nodo actual: $\{c, e, f, a, d\}$

\item Elijo para añadir el primer elemento de $F$ elegible según $(*)$: \{b,g\}
      Nodo actual: $\{c, e, f, a, d, b, g\}$

\item Llegué al objetivo. Fin. El algoritmo responde ``sí''.
\end{enumerate}

\end{enumerate}

% Pregunta 2
\section{}

\begin{enumerate}

 \item

Tomemos $A$ como un arreglo (sin pérdida de generalidad). En el grafo implícito, un vértice es
una asignación parcial $(A_1, A_2)$: cada elemento en $A[0 \ldots k)$ para algún $k \geq 0$ a uno de los dos multiconjuntos
$A_1$ o $A_2$.
Se tiene una asignación válida (aunque no necesariamente óptima) cuando se llega a un nodo final (lo que significa que $k = n$).
Los sucesores de un vértice no final con $k$ variables asignadas
son los resultantes de incluir $A[k]$ en $A_1$ o en $A_2$.

Supongamos que, para una instancia del problema, $(S, T)$ es una solución óptima
y $A[0] \in S$. Entonces $(T, S)$ también es una solución óptima, ya que

$$
\left|\sum_{e \in S} e - \sum_{e \in T} e\right| = \left|\sum_{e \in T} e - \sum_{e \in S} e\right|
$$

Por lo tanto, el multiconjunto en el cual se incluye el primer elemento del arreglo no cambia la solución.
Entonces se puede elegir como nodo inicial del grafo $(A_1 = \{A[0]\}, A_2 = \emptyset)$ y no explorar
la asignación de $A[0]$ a $A_2$.

Para decidir cuál es el siguiente nodo a expandir en un momento dado tomaré todos los
sucesores no visitados del nodo actual y elegiré alguno que tenga la mínima cota
superior según la función de acotamiento. En caso de no existir ninguno, haré backtracking.
La función de acotamiento es descrita en la siguiente sección.

 \item

La función de acotamiento $h$ aplicada a un nodo $x = (A_1, A_2)$ en que están asignados los $k$
primeros elementos de $A$ cumple 

$$
h(x) = \left| \left(\left|\sum_{e \in A_1} e - \sum_{e \in A_2} e\right|\right) - \sum_{i=k}^n A[i] \right|
$$

Es fácil ver que eso es una cota superior para cualquier asignación alcanzable desde $x$, ya que es el resultado
de asignar todos los elementos que quedan por decidir al 

 \item


\end{enumerate}

% Pregunta 3
\section{}

Supongo que ordenamos los tipos de objeto de la manera sugerida en la sección 9.7.2 del libro.
El grafo implícito sobre el cual se ramifica tiene como nodos asignaciones parciales de cantidades
de objetos de cada tipo, de la forma $x_1 \ldots x_k, 0 \leq k \leq n$ como se describe en el libro. Los sucesores
de un nodo son aquellos que resultan de extender su asignación parcial ya sea incrementando $x_k$ en uno o
eligiendo si se puede $x_{k+1} = 1$, siempre y cuando se satisfaga la restricción de peso de la mochila.
Usando el mismo argumento de la sección 9.6.1 del libro, no hay pérdida de generalidad
si no consideramos incrementar los $x_j$ con $j < k$. Un nodo final es aquel que no tiene sucesores.

La función de acotamiento es

Criterio de escogencia

A continuación el algoritmo aplicado paso a paso:

\renewcommand{\labelenumi}{\arabic{enumi}.}

\begin{enumerate}

\item Comienzo la búsqueda sin 

\end{enumerate}

\end{document}
