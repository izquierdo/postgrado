\documentclass{article}

\usepackage[utf8x]{inputenc}
\usepackage[spanish]{babel}

\begin{document}

\title{Instanciación Óptima de Flujos de Trabajo Abstractos Usando Lógica y Circuitos}
\maketitle

\section{Resumen}

La Arquitectura Orientada a Servicios típica consiste de dos capas principales.
La capa concreta con servicios concretos cuyas funcionalidades son descritas en
términos de pre- y post-condiciones y propiedades no funcionales en términos de
parámetros de calidad de servicio (Quality Of Service, QoS), y la capa abstracta
con aplicaciones de software cuyas funcionalidades son descritas en términos de
flujos de trabajo abstractos y propiedades no funcionales en términos de
restricciones sobre QoS. Durante la ejecución de un flujo de trabajo, los
servicios abstractos son instanciados en servicios concretos que cumplen con los
requerimientos funcionales y no funcionales. Esta instanciación, que debe ser
hecha en el momento, consiste de una búsqueda en un espacio de posibilidades
combinatorio. En este trabajo se propone una infraestructura para resolver
eficientemente el problema de instanciación que está firmemente basada en
lógica. La infraestructura adopta la aproximación Local-As-View en la cual la
funcionalidad de servicios concretos se describe usando vistas de servicios
abstractos, la calidad de una instanciación como una función de utilidad global
que combina los diferentes parámetros QoS, y los flujos de trabajo abstractos
como consultas conjuntivas sobre servicios abstractos. Usando esta
representación, el problema de instanciación de flujos de trabajo se convierte
en un problema de reescritura de consultas, del área de sistemas de integración.
Entonces, construyendo sobre trabajo relacionado, se idea una codificación del
problema de instanciación de flujos de trabajo como una teoría lógica cuyos
modelos están en correspondencia con las instanciaciones del flujo de trabajo, y
los modelos mejor puntuados en correspondencia con instanciaciones óptimas del
flujo de trabajo. Así, explotando propiedades conocidas de teorías lógicas en
formato d-DNNF, se provee una solución eficiente y escalable al problema de
instanciación de flujos de trabajo. Esta aproximación no sólo escala a
instancias grandes como muestran resultados experimentales ya realizados, sino
que también es correcta y completa dado que, estándo basada en la lógica, es
amigable al análisis formal.

\section{Introducción}

Bajo la sombra de la Web Semántica, y soportado por Arquitecturas Orientadas a
Servicios (SOA), el número de fuentes de datos y servicios Web ha explotado en
los últimos años. Por ejemplo, la colección de bases de datos de biología
molecular actualmente contiene 1170 bases de datos XREF22W, un número que es
mayor que el del último año XREF21W por 95, y que el de hace dos años por 110
XREF20W; las herramientas y servicios, así como el número de instancias
publicados por estos recursos, siguen una progresión similar XREF6W. Gracias a
este tesoro de datos, la tendencia de los usuarios es hacia depender cada vez
más en métodos automáticos para manejarlos tales como recuperación de datos de
fuentes públicas y análisis utilizando herramientas o servicios Web compuestos
en flujos de trabajo complejos.

La SOA típica consiste de dos capas. La capa concreta que está hecha de
servicios concretos cuyas funcionalidades son descritas en términos de pre- y
post-condiciones y propiedades no funcionales en términos de parámetros QoS, y
la capa abstracta compuesta de aplicaciones de software cuyas funcionalidades
son descritas en términos de flujos de trabajo abstractos y propiedades no
funcionales en términos de restricciones de QoS. La ejecución de un flujo de
trabajo abstracto involucra la instanciación de los servicios abstractos en
servicios concretos que cumplen con los requerimientos funcionales y no
funcionales. Este proceso de instanciación puede ser visto como una búsqueda de
una instanciación objetivo en el espacio combinatorio de todas las
instanciaciones válidas. Así, uno está interesado en técnicas eficientes para
realizar esta búsqueda que sean capaces de escalar a medida que el número de
servicios concretos o la complejidad del flujo de trabajo aumenta. Se llama al
problema de instanciar un flujo de trabajo dado con servicios concretos, de un
conjunto dado de servicios concretos, de manera que ciertas demandas de QoS sean
cumplidas, el Workflow Instantiation Problem (WIP, "Problema de Instanciacion de
Flujos de Trabajo").

En este trabajo se considera una versión restringida de WIP que adopta la
aproximación Local-As-View (LAV) XREF28W. En LAV, todos los elementos de un
problema son especificados con un lenguaje común basado en servicios abstractos
tal que los servicios concretos se describen como vistas de servicios
abstractos, la calidad de una instanciación como una función de utilidad global
que combina los diferentes parámetros QoS, y el flujo de trabajo abstracto como
una consulta conjuntvia sobre los servicios abstractos; esta representación es
similar a la que es generada de manera semiautomática para el sistema DEIMOS
XREF3W. En esta versión de WIP, las reglas que definen flujos de trabajo
(consultas conjuntivas) y servicios concretos (vistas) son creados de manera que
todas las restricciones funcionales sobre pre- y post-condiciones de los
servicios y sus combinaciones sean satisfechas, y las medidas de QoS son
representadas anotando cada descripción de servicio concreto con un número real
que representa la utilidad QoS global del servicio.

Bajo estas suposiciones, WIP puede ser convertido en el bien conocido Problema
de Reescritura de Consultas (QRP) para LAV que es central a los sistemas de
integración XREF23W. QRP consiste de una consulta conjuntiva que debe ser
respondida en términos de vistas donde la consulta y las vistas son descritas
usando LAV con relaciones abstractas. Este problema es importante en el contexto
de integración de datos XREF13X24W, y optimización de consultas y mantenimiento
de datos XREF1,28W, y varias aproximaciones que escalan a un número grande de
vistas han sido definidas XREF4,18,19,28,29W.

La aproximación recente de Arvelo et al. XREF4W está basada en la enumeración
eficiente de modelos de una teoría lógica proposicional. Dado unQRP, una teoría
lógica es construída de manera que cada modelo de la teoría codifica una
reescritura válida, y así todas las reescrituras son obtenidas enumerando los
modelos de la teoría. Esta enumeración puede ser realizada eficientemente si la
teoría lógica está en cierta forma normal llamada la forma normal de negación
determinística y descomponible (d-DNNF por sus siglas en inglés) XREF14W. Así,
la aproximación consiste en transformar (llamado compilar en el campo de
compilación del conocimiento) la teoría lógica en el formato d-DNNF para
enumerar sus modelos eficientemente.

Pero las teorías d-DNNF no sólo soportan la enumeración eficiente de sus
modelos, sino también otras operaciones. Entre ellas se encuentra la enumeración
de los modelos con mejor puntuación. Dada una función de puntuación de literales
$r(l)$ que asigne puntuaciones a cada literal $l$, se define la puntuación
$r(w)$ de un modelo $w$ como la suma de las puntuaciones de los literales
activados por $w$ (es decir, $r(w) = suma...$, y se dice que $w$ es un modelo
mejor puntuado si no hay modelo $wpriemrie$ tal que $r(w)...$.

Dada una teoría en d-DNNF, se computa la puntuación de los mejores modelos, y
los mejores modelos, en tiempo lineal en el tamaño del d-DNNF. Este cómputo
transforma el GAD del d-DNNF en un circuito aritmético reemplazando los nodos
AND con '+' y los nodos OR con 'min'. La función de puntuación de literales
asigna valores a las hojas del circuito que son propagados a la raíz en tiempo
lineal. El valor de la raíz es la puntuación del mejor modelo XREF17W.

En este trabajo, se explotan las propiedades de los d-DNNF construyendo una
teoría lógica cuyos modelos codifican las instanciaciones del flujo de trabajo
y cuyos mejores modelos codifican las instanciaciones óptimas (mejores). Así, la
búsqueda combinatoria se reduce a la computación de un mejor modelo de una
teoría lógica que puede ser realizada eficientemente una vez que la teoría sea
transformada en formato d-DNNF.

Esta propuesta contiene seis secciones más. La próxima sección ilustra y motiva
WIP con un ejemplo simple pero típico. La sección 3 resume el trabajo existente
relacionado en tres áreas de selección de servicios, reescritura de consultas y
compilación del conocimiento. Entonces, las secciones 4 y 5 describen la
arquitectura del sistema y reportan los resultados empíricos obtenidos hasta
ahora sobre distintos problemas de prueba respectivamente. La sección 6 presenta
una descripción formal de la aproximación propuesta junto con un análisis. La
propuesta concluye con una discusión final en la sección 7.

\section{Ejemplo motivante}

Considere un sistema simple de información de vuelos que contiene información
sobre vuelos entre ciudades e información sobre qué ciudades están en los
Estados Unidos. Un sistema así puede ser descrito usando LAV con los dos servicios
abstractos $flight$ y $uscity$. El primero relaciona dos ciudades $x$ e $y$ si
hay un vuelo directo entre ellas, y el segundo dice si $x$ es una ciudad de
E.E.U.U.  o no. Para los servicios concretos, supongamos que las fuentes de
datos disponibles en Internet contienen la siguiente información:

\begin{itemize}
TODO
-national
\end{itemize}

Adicionalmente, los servicios concretos se describen con los siguientes
servicios abstractos:

\begin{itemize}
TODO
-national
\end{itemize}

Ahora supongamos que un usuario está interesado en construir un flujo de trabajo
capaz de recuperar los vuelos ida y vuelta con una parada hacia cualquier ciudad
en el mundo, tales que los vuelos puedan detenerse en cualquier ciudad.

$$
W(x,w,y,z)
$$

La siguiente consulta conjuntiva representa el flujo de trabajo que define esta
solicitud en términos de servicios abstractos. El flujo de trabajo es definido
de manera que todo lo relacionado sobre el ligamiento de parámetros de
entrada/salida es resuelto. Así, cualquier instanciación de los servicios
abstractos en términos de los servicios concretos es una implementación válida
del flujo de trabajo. Las implementaciones corresponden a composiciones de
ervicios concretos en las cuales un servicio concreto puede implementar uno o
más servicios abstractos del flujo, pero cada servicio abstracto puede ser
implementado por exactamente un servicio concreto. Por ejemplo, la siguiente
composición corresponde a una de estas implementaciones.

$$
I(x
$$

Sin embargo, las siguientes dos composiciones no son válidas.

$$
I'
I''
$$

La primera composición no es válida porque asocia la variable del flujo $y$ a
las constantes PA y NY que denotan ciudades diferentes. En la otra mano, $I''$
no lo implementa porque el servicio concreto $ones-stop$ no recibe como entrada
o produce como salida la ciudad intermedia donde el vuelo se detiene y entonces
no es posible asegurarse de que esa ciudad esté asociada a la ciudad $w$ que es
retornada por el flujo de trabajo.

Estos ejemplos muestran que las instanciaciones correctas de un flujo deben
manejar constantes de manera que ods constantes distintas no sean asociadas
entre sí de manera directa o indirectamente vía transitividad, y que todos los
atributos que aprezcan en un TODOemphjoin o en la salida sean producidos por los
servicios concretos seleccionados.

Los parámetros QoS son modelados anotando los servicios concretos con utilidades
que caracterizan su comportamiento que luego son agregados durante la
instanciación. Así, como se mencionó previamente, la mejor instanciación es la
que minimiza (o maximiza) la agregación de utilidades.

\emph{Trabajo Relacionado}

En esta sección se resumen las aproximaciones existentes que proveen soluciones
a los problemas de selección de servicios y reescritura de consultas y se
discute el trabajo relacionado en el área de inteligencia artificial llamado
compilación del conocimiento.

\subsection{Selección de Servicios}

El problema de seleccionar los servicios que implementan un flujo de trabajo
abstracto y cumplen mejor los criterios basados en QoS es conocido como el
problema de selección o composición de servicios consciente de QoS, que ha sido
demostrado ser NP-difícil XREF34W. Este es un problema de optimización
combinatoria y varias heurísticas han sido propuestas para conseguir una
solución relativamente buena en un período razonablemente corto de tiempo.

Rahmani et al. XREF31W presenta una heurística basada en métrica de distancia
que guía un algoritmo de búsqueda hacia atrás; esta métrica induce un orden de
los servicios en una manera en que los nodos vertedero tienen baja probabilidad
de ser visitados. En una serie de artículos, Berardi y otros XREF7-9W describen
servicios y flujos de trabajo en términos de máquinas de estados finitos
determinísticas que son codificadas usando teorías de Lógica de Descripción
cuyos modelos corresponden a soluciones del problema. Aunque se podrían explotar
métodos para formalismos de Lógicas de Descripción, no han sido reportados la
escalabilidad o el rendimiento de la solución propuesta.

Ko et al. XREF25W propone una aproximación basada en restriccciones que codifica
los valores permisibles no funcionales como un conjunto de restricciones cuya
violación debe ser minimizada; para recorrer el espacio de soluciones
posiblemente óptima, se implementa un algoritmo híbrido que combina las
metaheurísticas TODOemphtabusearch y TODOemphsimulatedannealing. Los resultados
experimentales muestran que la solución propuesta es capaz de escalar a un
número grande de servicios y procesos abstractos. Cardellini et al. XREF12W
codifican una parte del problema de composición de servicios consciente de QoS
como un problema de programación lineal XREF12W. Por otra parte, Wada et al.
XREF34W trata el problema como uno de optimización con múltiples objetivos donde
los diferentes parámetros de QoS son considerados igualmente importanes en vez
de ser agregados en una función. Luego se propone un algoritmo basado en
algoritmos genéticos que identifica un conjunto de composiciones de servicios
no dominadas que mejor encajan en los requerimientos QoS.

Alrifai y Risse XREF2W proponen una solución de doble cara que usa un
algoritmo de programación entera híbrido para obtener la descomposición de QoS
globales en restricciones locales y luego selecciona los servicios que mejor
cumplen las restricciones locales.

Recientemente, dos aproximaciones basadas en planificación han sido propuestas.
Kuter y Golbek XREF26W extienden el algoritmo de planificación SHOP2 para
seleccionar la composición confiable de servicios que implementan un modelo de
procesos OWL-S dado, mientras que Sohrabi y McIlraith XREF33W proponen una
solución basada en planificación HTN donde las métricas de preferencia del
usario y regulaciones de dominio son utilizadas para guíar el planificador hacia
el espacio de composiciones relevantes. Finalmente, Lécué XREF27W propone un
algoritmo basado en genética para identificar la composición de servicios que
mejor cumple con los criterios de calidad para un conjunto de parámetros QoS.

Aunque estas soluciones son capaces de resolver el problema de optimización y
escalar a un número de procesos abstractos, ninguno de ellos está ajustado para
describir semánticamente los servicios en términos de procesos abstractos, ni
para usar estas descripciones para identificar los servicios que implementan un
flujo de trabajo dado o que mejor cumplen los criterios no funcionales del
usuario.

\subsection{Reescritura de Consultas}

Un número de algoritmos han sido desarrollados para encontrar las reescrituras
de una consulta dada; los más prominentes son el algoritmo bucket XREF28W, el
algoritmo de reglas inversas XREF18,30W, el algoritmo MiniCon XREF29, y el
algoritmo McdSat XREF4W. Generalmente, la reescritura de consultas trabaja en
dos fases. Durante la primera, el algoritmo identifica las vistas que reescriben
al menos un subobjetivo de la consulta, y durante el segundo estas reescrituras
parciales son combinadas en reescrituras completas. La diferencia principal
entre los algoritmos es el conjunto de criterios usado para elegir las vistas
relevantes para reducir el espacio de reescrituras no útiles.

El algoritmo bucket reduce el número de posibilidades considerando sólo cada
subobjetivo de la consulta aislado, y seleccionando las vistas que son capaces
de producir al menos los atributos proyectados por la consulta. Como los
atributos involucrados en los joins de la consulta no son verificados, un número
grande de reescrituras comprendido por productos cartesianos puede ser generado.

El algoritmo de reglas inversas construye un conjunto de reglas que invierten
las definiciones de vistas y establecen cómo computar tuplas para las relaciones
de la base de datos desde las tuplas de las vistas. Al igual que el algoritmo
bucket, puede producir un gran número de reescrituras no útiles.

El algoritmo MiniCon supera las limitaciones de los algoritmos previos
identificando solamente vistas que reescriben un conjunto de los subobjetivos de
la consulta, y que pueden ser combinados con el resto de los subobjetivos. La
idea principal es identificar las asociaciones entre variables de cada
subobjetivo a las variables en uno o más subojbetivos en las vistas, de manera
que las variables de join de la consulta son asociadas a las variables de join
del cuerpo de una vista o a variables distinguidas de la vista. Asociaciones
entre variables y subojbetivos son representadas en las llamadas TODOemphMiniCon
Descriptions (MCDs) XREF29W.

Finalmente, el algoritmo McdSat es capaz de identificar las reescrituras de una
consulta traduciendo el problema de reescritura al problema de enumeración de
modelos de una teoría proposicional cuyos modelos están en correspondencia con
las reescrituras de la consulta. El algoritmo explota las propiedades de los
d-DNNF para enumerar eficientemente los modelos de la teoría. El algoritmo
McdSat ha demostrado escalar mejor que el algoritmo MiniCon sobre un número
grande de experimentos donde frecuentemente muestra mejoras de rendimiento de
varios órdenes de magnitud. Sin embargo, el algoritmo McdSat no fue diseñado
para problemas de reescritura que involucren constantes explícitas, ni para
computar las mejores reescrituras respecto a una función de utilidad o modelo de
costo dado. En este trabajo se propone una codificación extendida que supera
estas limitaciones y se aplica la codificación al problema de instanciación de
flujos de trabajo.

\subsection{Compilación del conocimiento}
TODO Fig1

Compilación del conocimiento es el área en inteligencia artificial que se ocupa
del problema de traducir teorías lógicas en fragmentos apropiados que hagan
tratables ciertas operaciones deseadas XREF11W. Diferentes lenguajes de
compilación han sido definidos. Por ejemplo están los TODOemphtodoesto Ordered
Binary Decision Diagrams (OBDDs) XREF10W, Negation Normal Form (NNF) XREF5W, y
Decomposable Negation Normal Form (DNNF) XREF16W. En este trabajo se usan las
propiedades de los DNNFs determinísticos (d-DNNF) XREF14W para proveer una
solución eficiente y escalable al problema de selección de serviccios.

Una teoría en Negation Normal Form es construida desde literales usando sólo
conjunciones y disjunciones XREF5W, y puede ser representada como un grafo
acíclico dirigido en que las hojas son etiquetadas con literales y los nodos
internos con $TODOand$ y $TODOor$; ver ejemplo en la figura  1TODOLABELREF. Este
fragmento es universal, lo que significa que para cada fórmula lógica hay una
equivalente en formato NNF. Se dice que un NNF es descomponible (DNNF) XREF14W
si para cada conjunción $TODOformula$, sus variables son disjuntos por pares; es
decir, $TODO formula vars y vars$ para $i TODOnoigual j$. Un DNNF soporta un
número de operaciones en tiempo polinomial en el tamaño de su GAD. Por ejemplo,
podemos probar si un DNNF es satisfactible haciendo una simple pasada de abajo
hacia arriba sobre su GAD en tiempo linear. Se dice que un DNNF es
determinístico (d-DNNF) XREF14W si para cada disjunción $TODOformula$, los
disjuntos sob lógicamente contradictorios por pares, es decir, $TODO formula
false idistintoj$. El NNF en la figura 1TODOLABELREF, por ejemplo, es
decomposableTODOemph y determinístico. Un d-DNNF soporta conteo de modelos en
tiempo polinomial en el tamaño de su GAD, y enumeración de modelos en tiempo
polinomial en el tamaño de la salida. Además, dada una función de puntuación de
literales $r$, se puede computar la puntuación del mejor modelo en tiempo
polinomial para DNNFs XREF17W.

Los fragmentos DNNF y d-DNNF son universales pero traducir una teoría CNF a
formrato DNNF tiene costo exponencial en el peor caso. Esta traducción se
llama compilación en este campo. Hay un compilador públicamente disponible,
llamado c2d TODOfootnote que realiza este proceso de compilación y que hace uso
de técnicas de SAT modernas como backtracking dirigido por conflictos,
aprendizaje de cláusulas y caching XREF15W. Este compilador entra en el peor
caso en espacio exponencial en un parámetro llamado el ancho del árbol de
descomposición que está relacionado a la TODO"conectividad" de la teoría CNF.
Sin embargo, en nuestros experimentos, las teorías CNF que son compiladas son de
ancho pequeño.

\section{Arquitectura del sistema}

TODOfig2 system arquitecthuere

Se utiliza una arquitectura comprendida por un catálogo de descripciones de
servicio, el Codificador, el compilador c2d, el Buscador de mejores modelos, y
el Decodificador. La figura TODOREF2 muestra la arquitectura global del sistema.
En estta infraestructura, una instancia del problema de instanciación de lfujos
de trabajo se define como un flujo abstracto representado por una consulta
conjuntiva sobre servicios abstractos que es dada como entrada junto con un
conjunto de servicios concretos definidos por vistas de servicios abstractos.

El catálogo se pobla con descripciones de servicios abstractos y concretos; cada
servicio es descrito en términos de atributos de entrada y salida y anotado con
un valor real que representa la utilidad QoS del servicio. La descripción de los
servicios concretos, que son definidos como vistas de los servicios abstractos,
puede ser generada de manera semiautomática o automática usando herramientas
tales como el sistema DEIMOS XREF3W.

Una instancia de entrada de WIP es codificada como una teoría CNF cuyos modelos
corresponden a las intanciaciones del flujo de trabajo por el Codificador. El
compilador c2d, un componente TODOemphofftheshelf, compila la fórmula CNF a
d-DNNF. El Codificador traduce las instancias WIP en teorías CNF que luego son
convertidas en d-DNNF usando c2d. El Buscador computa un mejor modelo dados los
parámetros QoS en tiempo lineal en el tamaño del d-DNNF resultante. Es
importante remarcar que el proceso de compilación necesita ser realizado sólo
una vez ya que no depende del valor de los parámetros QoS. Así, incluso si la
compilación resulta ser costosa en términos de tiempo, este costo puede ser
amortizado dado que el d-DNNF resultante puede ser usado para conseguir mejores
instanciaciones con respecto a múltiples valores de los parámetros QoS.
Finalmente, el Decodificador traduce el mejor modelo retornado por el Buscardor
a una instanciación de flujo de trabajo que resuelve el WIP.

Dado un CNF que codifica un WIP, su d-DNNF es una representación compacta de
todas las instanciaciones del flujo de trabajo. Es decir, uno puede generar de
una manera libre de TODOemphbacktracking todas las instanciaciones del flujo de
trabajo. Si el usuario está interesado en una mejor instanciación dados
parámetros de QoS, entonces esta se puede computar en tiempo lineal en el tamñao
del d-DNNF. Si el usuario está interesado en todas las mejores instanciaciones,
estas pueden ser computadas en tiempo lineal en su número. FInalmente, si el
usuario está interesado en todas las instanciaciones, estas también pueden ser
computadas en tiempo lineal en su número. En los últimos dos casos, si ese
número es exponencial (en el tamaño de la entrada), la enumeración de las
instanciaciones también lo es pero esta complejidad es intrínsica al problema y
por lo tanto no puede ser evitada.

\section{Resultados Experimentales}

Se realizó un análisis empírico sobre tres experimentos. Todos lso experimentos
fueron realizados en una máquina de escritorio con un CPU Intel Core 2 Duo de
2GHz y 4GB de memoria, y el tiempo fue medido con el comando de Unix
timeTODOemph.

El objetivo del experimento es determinar el rendimiento de la propuesta con
condiciones variantes. El principal beneficio de la aproximación propuesta es
que se puede compilar la teoría lógica para una instancia del problema y luego
calcular todas las instanciaciones, o las mejores, cualquier número de veces. El
modelo de costos para conseguir mejores instanciaciones puede ser cambiado sin
necesidad de recompilar la teoría lógica. Por lo tanto, la complejidad en tiempo
de nuestra aproximación es básicamente el tiempo para codificar el WIP como un
CNF más el tiempo para compilar el CNF en un d-DNNF y el tiempo para decodificar
los modelos. Los tiempos para codificar y decodificar son despreciables
comparados con el tiempo para compilar el CNF. Por esto, se enfoca en el tiempo
necesario para compilar los problemas de los experimentos.

El primer experimento consiste de problemas para consultas para viajes aéreos.
Los servicios concretos son de la forma $VTODO formula$ donde $AL_iTODO$ es una
constante que denota el nombre de una aerolínea, y $flightTODO$ relaciona las
ciudades $x$ e $y$ tales que hay un vuelo entre $x$ e $y$ servido por $ALITODO$.
Se supone que este servicio concreto retorna todos los vuelos entre dos ciudades
con una aerolínea específica. El flujo de trabajo tiene la forma

$$
Wx1...TODO
$$

El experimento incluye instancias para flujos de trabajo con 2 a 5 subobjetivos
y conjuntos de 10 a 100 servicios concretos. Los resultados para la compilación
son mostrados en el panel (a) de la figura TODO3. Este es un gráfico en escala
logarítmica que sugiere comportamiento sub-exponencial. En cualquier caso, los
resultados muestran buen rendimiento dado que instancias realísticas del
problema (conjuntos de 100 aerolíneas con vuelos de cinco paradas) pueden ser
compiladas en 328 segundos. El tamaño en disco del d-DNNF para 100 aerolíneas y
vuelos con cinco paradas es 3,4MB. En este d-DNNF, el mejor modelo puede ser
computado en 0.29 segundos, y la enumeración de todos los modelos en 0.47
segundos.

TODOfig3 experimentos

En un intento de inducir crecimiento exponencial en el tamaño de compilación, en
el segundo experimento se agrega un segundo servicio concreto para cada
aerolínea. Esta modificación incrementa el número de instanciaciones válidas de
lineal a exponencial dado que cada tramo de un vuelo puede ser ahora instanciado
por dos servicios concretos y entonces un vuelo con $n$ tramos puede tener hasta
$2^n$ instanciaciones. Se corrió el compilador para instancias que comprendían
el mismo número de subobjetivos del flujo de trabajo y el número total de
servicios concretos. Los resultados graficados en escala logarítmica se muestran
en el panel (b) de la figura TODO3.

Estas pruebas muestran buen rendimiento para este tipo de problemas, pero no
involucran servicios concretos con múltiples subobjetivos. Por lo tanto se
diseñó un tercer experimento que consiste de instancias no estructuradas y
generadas aleatoriamente. Cada instancia contiene tres variables por servicio
abstracto, diez variables distintas y diez constantes distintas, seis
subobjetivos en los flujos de trabajo, 2 a 5 subobjetivos en los servicios
concretos, y número de servicios variante. La probabilidad de que un argumento
de un servicio abstracto esté ligado a una constante es 50\%. Los resultados se
muestran en la figura TODO4. El tiempo de compilación de estas instancias no
crece monótonamente dado que son generadas aleatoriamente. Lo mismo ocurre para
el tamaño de las teorías y los números de modelos. Por ejemplo, el d-DNNF para
un problema con 45 vistas cada una con 5 subobjetivos fue de tamaño 5,1Mb y tuvo
$1.26 TODO 20101028$ modelos. El tiempo para buscar el mejor modelo para este
d-DNNF es 0.46 segundos mientras que el tiempo para enumerar todos los modelos
es alredededor de 17 horas.

Estos son experimentos preliminares, pero los resultados muestran que la
aproximación propuesta escala eficientemente para problemas con varios objetivos
y vistas. Se cree que estos resultados son alentadores y motivan a continuar
esta línea de investigación.

\section{Formalización}

Consideramos cat[alogos de servicio de la forma $C = ST$ donde $S$ es un
conjunto de predicados que representa servicios abstractos y $T=TTODO$ es una
colección de tablas que representa el resultado de evaluar los servicios
abstractos. En el contexto del WIP, un catálogo de servicio $C$ es una
descripción idealizada de la salida producida por flujos abstractos
implementados por servicios concretos descritos como vistas. Un flujo de trabajo
$W$ sobre $S$ es una consulta conjuntiva de la forma

$$
WX
$$

donde $si,x$ es un vector de variables y cada $xi$ es un vector de variables y
constantes. El resultado de $W$ sobre $C$, denotado como $W(C)$, es la tabla con
$|x|$ columnas que resulta de la proyección del TODOemphjoin relacional
$JOINTODO$ sobre $x$. Los átomos en el cuerpo de $W$ son llamados los
(sub)objetivos de $W$, y las variables en la cabeza de $W$ son llamados
distinguidos.

Un servicio concreto es descrito como una vista $V$ sobre $C$ que, siguiendo
LAV, es una consulta sobre $S$. Dado un catálogo $C$, un flujo de trabajo $W$ y
una colección de $n$ vistas $E=$, se nos pide conseguir todas las tuplas en
$W(C)$ que puedan ser obtenidas de vistas en $E$. Es decir, se necesitan
conseguir las instanciaciones

$$
R(x)
$$

tales que $R(E)...$. Un problema de instanciación de flujo de trabajo es una
tupla $tUTPLA$ donde $S$ es un conjunto de predicados que representa servicios
abstractos, $W$ es un flujo de trabajo sobre $S$, y $VI$ una colección de vistas
que define servicios concretos. Suponemos trabajo con problemas \emph{seguros}
en el sentido en que todas las variables mencionadas en la cabeza del flujo de
trabajo (respectivamente en la cabeza de cada vista) aparecen en el cuerpo del
flujo de trabajo (respectivamente en el cuerpo de cada vista). Además, sólo
lidiamos con WIPs sin predicados aritméticos dentro del flujo de trabajo o
vistas. Una instanciación $R$ es válida si para todos los catálogos $C=$ y
extensiones $EIII$, $R(E#)$. Una colección $R$ de instanciaciones válidas es una
solución si para todos los catálogos de servicio $C=$ y extensiones $EII$, no
existe $R'$ tal que $R(E= C$.

\end{document}
